<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GVC Badge Lookup</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a0f;
            --bg-card: #12121a;
            --bg-hover: #1a1a25;
            --border: #2a2a3a;
            --text-primary: #ffffff;
            --text-secondary: #888899;
            --accent-cyan: #00d4ff;
            --accent-green: #00ff88;
            --accent-pink: #ff44aa;
            --accent-purple: #a855f7;
            --accent-orange: #ff9500;
            --accent-gold: #ffd700;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }
        
        /* Header */
        .header {
            text-align: center;
            padding: 48px 0;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }
        
        /* Search Section */
        .search-section {
            max-width: 600px;
            margin: 0 auto 48px;
        }
        
        .search-box {
            display: flex;
            gap: 12px;
        }
        
        .search-box input {
            flex: 1;
            padding: 16px 20px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 16px;
            font-family: 'JetBrains Mono', monospace;
            transition: border-color 0.2s;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }
        
        .search-box input::placeholder {
            color: var(--text-secondary);
            font-family: 'Inter', sans-serif;
        }
        
        .search-box button {
            padding: 16px 32px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            border: none;
            border-radius: 12px;
            color: #000;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .search-box button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 212, 255, 0.3);
        }
        
        .search-hint {
            text-align: center;
            margin-top: 12px;
            color: var(--text-secondary);
            font-size: 13px;
        }
        
        /* Results Section */
        .results {
            display: none;
        }
        
        .results.active {
            display: block;
        }
        
        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }
        
        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
        }
        
        .stat-card .value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .stat-card .label {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .stat-card.cyan .value { color: var(--accent-cyan); }
        .stat-card.green .value { color: var(--accent-green); }
        .stat-card.pink .value { color: var(--accent-pink); }
        .stat-card.gold .value { color: var(--accent-gold); }
        
        /* Completion Bar */
        .completion-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 32px;
        }
        
        .completion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .completion-header h3 {
            font-size: 16px;
            font-weight: 600;
        }
        
        .completion-header span {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-cyan);
        }
        
        .progress-bar {
            height: 12px;
            background: var(--bg-dark);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple));
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        
        /* Badge Tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
        }
        
        .tab {
            padding: 12px 24px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tab:hover {
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }
        
        .tab.active {
            background: var(--bg-hover);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }
        
        .tab.missing {
            border-color: var(--accent-pink);
        }
        
        .tab.missing.active {
            color: var(--accent-pink);
            border-color: var(--accent-pink);
        }
        
        /* Badge Grid */
        .badge-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
        }
        
        .badge-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.2s;
            flex-wrap: wrap;
        }
        
        .badge-item:hover {
            border-color: var(--accent-cyan);
            transform: translateX(4px);
        }
        
        .badge-item.missing {
            opacity: 0.7;
        }
        
        .badge-item.missing:hover {
            border-color: var(--accent-pink);
        }
        
        .badge-name {
            font-weight: 500;
            font-size: 15px;
        }
        
        .badge-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .badge-item.missing .badge-count {
            color: var(--accent-pink);
        }
        
        /* Combo badge progress bar */
        .combo-progress {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .combo-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple));
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        /* Special badge note */
        .badge-note {
            width: 100%;
            font-size: 11px;
            color: var(--accent-orange);
            margin-top: 6px;
            font-style: italic;
        }
        
        /* Bounty Hunter checkbox */
        .bounty-checkbox-container {
            width: 100%;
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .bounty-checkbox-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-cyan);
        }
        
        .bounty-checkbox-container label {
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        /* NFT Preview Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 24px;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 20px;
            max-width: 900px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
        }
        
        .modal-header h2 {
            font-size: 18px;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
        }
        
        .modal-close:hover {
            color: var(--text-primary);
        }
        
        .modal-body {
            padding: 24px;
            overflow-y: auto;
        }
        
        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
        }
        
        .nft-card {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
        }
        
        .nft-card:hover {
            transform: scale(1.05);
            border-color: var(--accent-cyan);
        }
        
        .nft-card img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            display: block;
        }
        
        .nft-card .nft-id {
            padding: 8px;
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            background: var(--bg-card);
        }
        
        /* Loading State */
        .loading {
            text-align: center;
            padding: 48px;
            color: var(--text-secondary);
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Error State */
        .error {
            text-align: center;
            padding: 48px;
            color: var(--accent-pink);
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding: 48px 0;
            color: var(--text-secondary);
            font-size: 13px;
        }
        
        .footer a {
            color: var(--accent-cyan);
            text-decoration: none;
        }
        
        /* Responsive */
        @media (max-width: 600px) {
            .header h1 { font-size: 1.8rem; }
            .search-box { flex-direction: column; }
            .search-box button { width: 100%; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .tabs { flex-wrap: wrap; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>ðŸ¤™ GVC Badge Lookup</h1>
            <p>Check your badge collection and find what you're missing</p>
        </header>
        
        <section class="search-section">
            <div class="search-box">
                <input type="text" id="walletInput" placeholder="Enter wallet(s), ENS name(s), or token IDs...">
                <button onclick="lookupWallet()">Look Up</button>
            </div>
            <p class="search-hint">Supports multiple wallets! Separate with commas: 0x123..., name.eth, 0x456...</p>
        </section>
        
        <section class="results" id="results">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Looking up badges...</p>
            </div>
            
            <div class="error" id="error" style="display: none;">
                <p>Could not find NFTs for this wallet. Try entering token IDs directly.</p>
            </div>
            
            <div id="resultsContent" style="display: none;">
                <div class="stats-grid">
                    <div class="stat-card cyan">
                        <div class="value" id="nftCount">0</div>
                        <div class="label">GVC NFTs</div>
                    </div>
                    <div class="stat-card green">
                        <div class="value" id="ownedBadges">0</div>
                        <div class="label">Badges Owned</div>
                    </div>
                    <div class="stat-card pink">
                        <div class="value" id="missingBadges">0</div>
                        <div class="label">Missing</div>
                    </div>
                    <div class="stat-card gold">
                        <div class="value" id="rarestBadge" style="font-size: 1rem;">-</div>
                        <div class="label">Rarest Badge</div>
                    </div>
                </div>
                
                <div class="completion-section">
                    <div class="completion-header">
                        <h3>Badge Completion</h3>
                        <span id="completionPct">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="tabs">
                    <button class="tab active" onclick="showTab('owned')">Owned (<span id="ownedTabCount">0</span>)</button>
                    <button class="tab missing" onclick="showTab('missing')">Missing (<span id="missingTabCount">0</span>)</button>
                </div>
                
                <div class="badge-grid" id="ownedGrid"></div>
                <div class="badge-grid" id="missingGrid" style="display: none;"></div>
            </div>
        </section>
        
        <footer class="footer">
            <p>Built for the <a href="https://opensea.io/collection/good-vibes-club" target="_blank">Good Vibes Club</a> community ðŸ¤™</p>
        </footer>
    </div>
    
    <!-- NFT Preview Modal -->
    <div class="modal-overlay" id="modal" onclick="closeModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 id="modalTitle">Badge Name</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="nft-grid" id="modalNFTs"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Badge data will be loaded from GVC's API
        let badgeData = {};
        let nftData = {};
        let imageData = {};
        let walletNFTs = [];
        let walletBadges = {};
        let missingBadgesList = [];
        let ownedTypesGlobal = []; // Store owned types for use in renderMissingBadges
        
        // VIBE Bounty Hunter self-report state (0, 1, or 2)
        let vibeBountyHunterCount = 0;
        
        // ===========================================
        // BADGE NAME MAPPINGS (API name -> Display name)
        // ===========================================
        const BADGE_DISPLAY_NAMES = {
            // NFT Trait Badges (62 from API)
            'any_gvc': 'Official Citizen of Vibetown',
            'astro_balls': 'Stellar Spheres',
            'astro_bean': 'AstroBean',
            'baller': 'Vibetown Baller',
            'billiards': "Rack Em' Up",
            'captain': 'Oh Captain My Captain',
            'checkmate': 'No Pawn Intended',
            'cosmic': 'Cosmic Guardian',
            'doge': 'Great \'Stacheby',
            'electric_rings': 'Atomic Aura',
            'elite_rainbow_ranger': 'Elite Rainbow Ranger',
            'full_send_maverick': 'Full Send Maverick',
            'full_throttle': 'Full Throttle',
            'funky_fresh': 'Funky Fresh',
            'fur_the_win': 'Fur The Win',
            'gamer': '360 No Scope',
            'gold_member': 'Golden Fever',
            'gradient_lover': 'Gradient Gatherer',
            'grayscale_seeker': 'Grayscale Hunter',
            'great_stacheby': 'Great \'Stacheby',
            'gud_meat': 'Gud Moot',
            'hail_mary_heroes': 'Hail Mary Heroes',
            'high_noon_hustler': 'High Noon Hustler',
            'homerun': 'Homerun',
            'hoodie_up_society': 'Hoodie Up Society',
            'king': 'Vibetown Royalty',
            'ladies_night': 'Ladies Night',
            'lamp': 'I Love Lamp',
            'necks_level': 'Rocks Level',
            'no_face_no_problem': 'No Face, No Problem',
            'nourish_vibes': 'Nourish Vibes',
            'one_of_one': 'One of One',
            'party_in_the_back': 'Party In The Back',
            'pepe': 'Pepe Posse',
            'plants': 'Aloe You Vera Much',
            'plastic_lover': 'Plastic Pioneer',
            'poker_face': 'Pocket Rockets',
            'pothead': 'High Vibes',
            'rainbow_boombox': 'Bass In Your Face',
            'rainbow_bubble_goggles': 'Bubble Visionary',
            'rainbow_citizen': 'Rainbow Maxi',
            'rainbow_visor': 'Visooor Enjoyooor',
            'ranger': 'Vibe Ranger',
            'robot_lover': 'Love at First Byte',
            'science_goggles': 'Bubble Visionary',
            'seas_the_day': 'Seas The Day',
            'shower': 'Soaked N\' Stoked',
            'showtime': 'Showtime',
            'sir_vibes_a_lot': 'Sir Vibes-a-lot',
            'stone': 'Marble Potential',
            'straw_man': 'Straw Man',
            'suited_up': 'Suited Up',
            'super_rare': 'SuperRare',
            'surfer': 'Get Pitted',
            'sweettooth': 'Sugar Rush',
            'tanks_a_lot': 'Tanks A Lot',
            'toy_bricks': 'Brick By Brick',
            'varsity_vibes': 'Varsity Vibes',
            'vibefoot_fan_club': 'Vibetoot Fan Club',
            'vibetown_social_club': 'Vibetown Social Club',
            'visooor_enjoyooor': 'Visooor Enjoyooor',
            'zoom_in_vibe_out': 'Zoom In, Vibe Out',
            // Combo badges
            'gradient_hatrick': 'Gradient Hatrick',
            'plastic_hatrick': 'Plastic Hatrick',
            'robot_hatrick': 'Robot Hatrick',
            'gradient_high_five': 'Gradient High Five',
            'plastic_high_five': 'Plastic High Five',
            'robot_high_five': 'Robot High Five',
            'power_duo': 'Power Duo',
            'chris_favorite': "Chris' Favorite Badge",
            'multi_type_master': 'Multi-Type Master',
            'yin_n_yang': "Yin N' Yang",
            'mountain_goat': 'Mountain GOAT',
            // Special badges
            'vibe_bounty_hunter': 'VIBE Bounty Hunter'
        };
        
        // Badge colors for display
        const BADGE_COLORS = {
            // Rainbow/Special
            'rainbow_citizen': 'linear-gradient(90deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6633ff)',
            'rainbow_visor': 'linear-gradient(90deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6633ff)',
            'rainbow_bubble_goggles': 'linear-gradient(90deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6633ff)',
            'science_goggles': 'linear-gradient(90deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6633ff)',
            'elite_rainbow_ranger': 'linear-gradient(90deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6633ff)',
            'rainbow_boombox': 'linear-gradient(90deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6633ff)',
            // Gold/Yellow themed
            'gold_member': '#ffd700',
            'doge': '#ffd700',
            'great_stacheby': '#ffd700',
            'showtime': '#ffa500',
            // Grayscale
            'grayscale_seeker': '#888888',
            'chris_favorite': '#888888',
            // Special/Rare
            'one_of_one': '#ff00ff',
            'super_rare': '#ff4500',
            'cosmic': '#9933ff',
            // Type lovers
            'robot_lover': '#00ffff',
            'plastic_lover': '#ff69b4',
            'gradient_lover': 'linear-gradient(90deg, #ff6b6b, #4ecdc4)',
            // General
            'any_gvc': '#00d4ff',
            'ranger': '#228b22',
            'pothead': '#32cd32',
            'pepe': '#00aa00',
            'gamer': '#9400d3',
            'checkmate': '#1a1a2e',
            'poker_face': '#006400',
            'captain': '#000080',
            'suited_up': '#1a1a2e',
            'ladies_night': '#ff1493',
            'party_in_the_back': '#8b4513',
            'funky_fresh': '#ff6347',
            'homerun': '#dc143c',
            // New badges
            'astro_balls': '#9933ff',
            'astro_bean': '#00d4ff',
            'baller': '#ff9500',
            'billiards': '#228b22',
            'electric_rings': '#00ffff',
            'full_send_maverick': '#00d4ff',
            'full_throttle': '#ff4500',
            'fur_the_win': '#8b4513',
            'gud_meat': '#ff6347',
            'hail_mary_heroes': '#000080',
            'high_noon_hustler': '#a855f7',
            'hoodie_up_society': '#00d4ff',
            'king': '#ffd700',
            'lamp': '#ffa500',
            'necks_level': '#a855f7',
            'no_face_no_problem': '#ffd700',
            'nourish_vibes': '#32cd32',
            'plants': '#32cd32',
            'seas_the_day': '#00d4ff',
            'shower': '#00d4ff',
            'sir_vibes_a_lot': '#a855f7',
            'stone': '#888888',
            'straw_man': '#ffa500',
            'surfer': '#00d4ff',
            'sweettooth': '#ff69b4',
            'tanks_a_lot': '#228b22',
            'toy_bricks': '#ff4500',
            'varsity_vibes': '#00d4ff',
            'vibefoot_fan_club': '#00d4ff',
            'vibetown_social_club': '#ff4500',
            'visooor_enjoyooor': '#00ffff',
            'zoom_in_vibe_out': '#00d4ff',
            // Collection badges (milestone badges)
            'collection_5': '#ff9500',
            'collection_10': '#c0c0c0',
            'collection_15': '#ffd700',
            'collection_20': '#a855f7',
            'collection_30': '#ff4500',
            'collection_40': '#ff69b4',
            'collection_50': '#00d4ff',
            // VIBESTR tier badges
            'vibestr_blue': '#87CEEB',
            'vibestr_pink': '#FF69B4',
            'vibestr_purple': '#9932CC',
            'vibestr_bronze': '#CD7F32',
            'vibestr_silver': '#C0C0C0',
            'vibestr_gold': '#FFD700',
            'vibestr_diamond': '#B9F2FF',
            'vibestr_cosmic': 'linear-gradient(90deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6633ff)',
            // Combo badges
            'gradient_hatrick': 'linear-gradient(90deg, #4ecdc4, #44a08d)',
            'plastic_hatrick': '#FF69B4',
            'robot_hatrick': '#00ffff',
            'gradient_high_five': 'linear-gradient(90deg, #4ecdc4, #44a08d)',
            'plastic_high_five': '#FF69B4',
            'robot_high_five': '#00ffff',
            'power_duo': '#ffd700',
            'multi_type_master': 'linear-gradient(90deg, #ff69b4, #4ecdc4, #00ffff)',
            'yin_n_yang': 'linear-gradient(90deg, #888888, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff)',
            'mountain_goat': '#87CEEB',
            // Special badges
            'vibe_bounty_hunter': '#a855f7'
        };
        
        // Collection badge display names
        const COLLECTION_BADGE_NAMES = {
            'collection_5': 'Collector of Epic Vibes',
            'collection_10': 'Collector of Exquisite Vibes',
            'collection_15': 'Collector of Legendary Vibes',
            'collection_20': 'Collector of Immaculate Vibes',
            'collection_30': 'Collector of Pristine Vibes',
            'collection_40': 'Collector of Transcendent Vibes',
            'collection_50': 'Collector of Magnificent Vibes'
        };
        
        function getBadgeColor(badge) {
            return BADGE_COLORS[badge] || '#00d4ff';
        }
        
        function formatBadgeName(badge) {
            // Check display name mapping first
            if (BADGE_DISPLAY_NAMES[badge]) {
                return BADGE_DISPLAY_NAMES[badge];
            }
            // Collection badges
            if (badge.startsWith('collection_')) {
                return COLLECTION_BADGE_NAMES[badge] || `${badge.replace('collection_', '')} Badges`;
            }
            // VIBESTR badges
            if (badge.startsWith('vibestr_')) {
                const tier = badge.replace('vibestr_', '');
                return `$VIBESTR ${tier.charAt(0).toUpperCase() + tier.slice(1)} Tier`;
            }
            // Fallback: format from snake_case
            return badge.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }
        
        // Load badge data from GVC API
        async function loadBadgeData() {
            try {
                const response = await fetch('https://www.goodvibesclub.io/assets/badge_token_map.json');
                const data = await response.json();
                
                console.log('Raw badge data:', data);
                
                // Badge data is in badgeToTokens property
                if (data.badgeToTokens) {
                    badgeData = data.badgeToTokens;
                } else {
                    badgeData = data;
                }
                
                // Also store tokenToBadges for faster lookup
                if (data.tokenToBadges) {
                    window.tokenToBadges = data.tokenToBadges;
                }
                
                console.log(`Loaded ${Object.keys(badgeData).length} badge types`);
            } catch (error) {
                console.error('Failed to load badge data:', error);
            }
        }
        
        // Load image URLs
        async function loadImageData() {
            try {
                const response = await fetch('gvc-images.json');
                imageData = await response.json();
                console.log(`Loaded ${Object.keys(imageData).length} image URLs`);
            } catch (error) {
                console.error('Failed to load image data:', error);
            }
        }
        
        // Load NFT type data for combo badge calculations
        let typeData = {};
        async function loadTypeData() {
            try {
                const response = await fetch('gvc-types.json');
                typeData = await response.json();
                console.log(`Loaded ${Object.keys(typeData).length} NFT types`);
            } catch (error) {
                console.error('Failed to load type data:', error);
            }
        }
        
        // Load special traits data for Mountain GOAT badge
        let specialTraitsData = {};
        async function loadSpecialTraitsData() {
            try {
                const response = await fetch('gvc-special-traits.json');
                specialTraitsData = await response.json();
                console.log(`Loaded special traits for ${Object.keys(specialTraitsData).length} NFTs`);
            } catch (error) {
                console.error('Failed to load special traits data:', error);
            }
        }
        
        // Initialize on page load
        loadBadgeData();
        loadImageData();
        loadTypeData();
        loadSpecialTraitsData();
        
        // Store resolved addresses for VIBESTR lookup
        let resolvedAddresses = [];
        
        async function lookupWallet() {
            const input = document.getElementById('walletInput').value.trim();
            if (!input) return;
            
            const results = document.getElementById('results');
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            const content = document.getElementById('resultsContent');
            
            results.classList.add('active');
            loading.style.display = 'block';
            error.style.display = 'none';
            content.style.display = 'none';
            
            // Reset resolved addresses and bounty hunter state
            resolvedAddresses = [];
            vibeBountyHunterCount = 0;
            
            try {
                let tokenIds = [];
                let vibestrBalance = 0;
                
                // Check if input is purely token IDs (only numbers, commas, spaces)
                if (/^[\d,\s]+$/.test(input)) {
                    tokenIds = input.split(',').map(id => id.trim()).filter(id => id);
                } else {
                    // Parse input for multiple wallets/ENS names
                    const inputs = input.split(/[,\n]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                    
                    console.log(`Looking up ${inputs.length} wallet(s):`, inputs);
                    
                    // Fetch NFTs from all wallets in parallel
                    const allResults = await Promise.all(
                        inputs.map(async (walletInput) => {
                            try {
                                return await fetchWalletNFTs(walletInput);
                            } catch (e) {
                                console.error(`Failed to fetch for ${walletInput}:`, e);
                                return [];
                            }
                        })
                    );
                    
                    // Combine all token IDs (use Set to avoid duplicates if same NFT appears)
                    const combinedSet = new Set();
                    allResults.forEach(ids => {
                        ids.forEach(id => combinedSet.add(id.toString()));
                    });
                    tokenIds = Array.from(combinedSet);
                    
                    console.log(`Combined total: ${tokenIds.length} unique NFTs from ${inputs.length} wallet(s)`);
                    
                    // Fetch VIBESTR balance for all resolved addresses
                    if (resolvedAddresses.length > 0) {
                        vibestrBalance = await fetchVibestrBalance(resolvedAddresses);
                        console.log(`Total VIBESTR balance: ${vibestrBalance}`);
                    }
                }
                
                if (tokenIds.length === 0) {
                    throw new Error('No NFTs found');
                }
                
                processResults(tokenIds, vibestrBalance);
                loading.style.display = 'none';
                content.style.display = 'block';
                
            } catch (err) {
                console.error(err);
                loading.style.display = 'none';
                error.style.display = 'block';
            }
        }
        
        async function fetchWalletNFTs(addressOrENS) {
            let address = addressOrENS;
            
            // Resolve ENS if needed
            if (addressOrENS.includes('.')) {
                try {
                    const ensResponse = await fetch(`https://api.ensideas.com/ens/resolve/${addressOrENS}`);
                    const ensData = await ensResponse.json();
                    if (ensData.address) {
                        address = ensData.address;
                    }
                } catch (e) {
                    console.log('ENS resolution failed, trying as address');
                }
            }
            
            // Store resolved address for VIBESTR lookup
            if (address.startsWith('0x')) {
                resolvedAddresses.push(address);
            }
            
            // Try Reservoir API first
            const CONTRACT = '0xb8ea78fcacef50d41375e44e6814ebba36bb33c4';
            
            try {
                const reservoirUrl = `https://api.reservoir.tools/users/${address}/tokens/v7?collection=${CONTRACT}&limit=200`;
                console.log('Trying Reservoir:', reservoirUrl);
                const response = await fetch(reservoirUrl);
                const data = await response.json();
                
                if (data.tokens && data.tokens.length > 0) {
                    const tokens = data.tokens.map(t => t.token.tokenId);
                    console.log(`Found ${tokens.length} NFTs via Reservoir`);
                    return tokens;
                }
            } catch (e) {
                console.log('Reservoir failed:', e);
            }
            
            // Fallback to Alchemy
            try {
                const alchemyUrl = `https://eth-mainnet.g.alchemy.com/nft/v3/demo/getNFTsForOwner?owner=${address}&contractAddresses[]=${CONTRACT}&withMetadata=false`;
                console.log('Trying Alchemy:', alchemyUrl);
                const response = await fetch(alchemyUrl);
                const data = await response.json();
                
                if (data.ownedNfts && data.ownedNfts.length > 0) {
                    const tokens = data.ownedNfts.map(nft => nft.tokenId);
                    console.log(`Found ${tokens.length} NFTs via Alchemy`);
                    return tokens;
                }
            } catch (e) {
                console.log('Alchemy failed:', e);
            }
            
            return [];
        }
        
        // Fetch VIBESTR token balance
        async function fetchVibestrBalance(addresses) {
            const VIBESTR_CONTRACT = '0xd0cc2b0efb168bfe1f94a948d8df70fa10257196';
            let totalBalance = 0;
            
            for (const address of addresses) {
                try {
                    // Use public RPC with eth_call (most reliable, no API key needed)
                    const balanceOfSelector = '0x70a08231';
                    const paddedAddress = address.toLowerCase().replace('0x', '').padStart(64, '0');
                    const callData = balanceOfSelector + paddedAddress;
                    
                    // Try multiple public RPCs
                    const rpcUrls = [
                        'https://rpc.ankr.com/eth',
                        'https://eth.llamarpc.com',
                        'https://1rpc.io/eth',
                        'https://ethereum.publicnode.com'
                    ];
                    
                    let success = false;
                    for (const rpcUrl of rpcUrls) {
                        if (success) break;
                        try {
                            console.log(`Trying RPC: ${rpcUrl}`);
                            const response = await fetch(rpcUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    jsonrpc: '2.0',
                                    method: 'eth_call',
                                    params: [{ to: VIBESTR_CONTRACT, data: callData }, 'latest'],
                                    id: 1
                                })
                            });
                            const data = await response.json();
                            
                            if (data.result && data.result !== '0x' && data.result !== '0x0') {
                                const balance = parseInt(data.result, 16) / 1e18;
                                totalBalance += balance;
                                console.log(`VIBESTR balance for ${address}: ${balance.toLocaleString()}`);
                                success = true;
                            }
                        } catch (e) {
                            console.log(`RPC ${rpcUrl} failed:`, e.message);
                        }
                    }
                    
                    if (!success) {
                        console.log(`Could not fetch VIBESTR balance for ${address} from any RPC`);
                    }
                } catch (e) {
                    console.log('VIBESTR balance fetch failed:', e);
                }
            }
            
            return totalBalance;
        }
        
        // Meta badges configuration
        const COLLECTION_BADGE_THRESHOLDS = [5, 10, 15, 20, 30, 40, 50];
        const VIBESTR_TIERS = [
            { name: 'vibestr_blue', threshold: 69000, color: '#87CEEB' },
            { name: 'vibestr_pink', threshold: 250000, color: '#FF69B4' },
            { name: 'vibestr_purple', threshold: 500000, color: '#9932CC' },
            { name: 'vibestr_bronze', threshold: 1000000, color: '#CD7F32' },
            { name: 'vibestr_silver', threshold: 2500000, color: '#C0C0C0' },
            { name: 'vibestr_gold', threshold: 4200000, color: '#FFD700' },
            { name: 'vibestr_diamond', threshold: 6900000, color: '#B9F2FF' },
            { name: 'vibestr_cosmic', threshold: 10000000, color: 'linear-gradient(90deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6633ff)' }
        ];
        
        // Type colors for High Five badges - the 5 (or 6) colors needed for each type
        const TYPE_COLORS = {
            'Gradient': ['Gradient Yellow Orange', 'Gradient Yellow Yellow', 'Gradient Pink Pink', 'Gradient Pink Magenta Red', 'Gradient Magenta Purple Blue', 'Gradient Cyan Blue Purple', 'Gradient Dark Blue Light Blue', 'Gradient Blue Purple Pink', 'Gradient Lime Yellow', 'Gradient Lime Seafoam', 'Gradient Red Purple'],
            'Plastic': ['Plastic Pink', 'Plastic Mint', 'Plastic Red', 'Plastic Yellow', 'Plastic Blue', 'Plastic Purple'],
            'Robot': ['Robot Red Candy Apple', 'Robot Lilac', 'Robot Ice', 'Robot Cobalt', 'Robot Pink']
        };
        
        // OpenSea search URLs for each type color
        const OPENSEA_SEARCH_BASE = 'https://opensea.io/collection/good-vibes-club?traits=';
        
        function getOpenSeaLink(typeColor) {
            const traitParam = JSON.stringify([{"traitType": "Type", "values": [typeColor]}]);
            return OPENSEA_SEARCH_BASE + encodeURIComponent(traitParam);
        }
        
        // Get missing colors for a type prefix
        function getMissingColors(ownedTypes, typePrefix) {
            const allColors = TYPE_COLORS[typePrefix] || [];
            const ownedColors = [...new Set(ownedTypes.filter(t => t && t.startsWith(typePrefix)))];
            return allColors.filter(color => !ownedColors.includes(color));
        }
        
        // Combo badges - based on owning NFTs with specific type combinations
        const COMBO_BADGES = [
            { 
                name: 'gradient_hatrick', 
                requirement: '3 different Gradient colors', 
                check: (types) => countUniqueByPrefix(types, 'Gradient') >= 3,
                progress: (types, tokenIds) => ({ current: countUniqueByPrefix(types, 'Gradient'), needed: 3 })
            },
            { 
                name: 'plastic_hatrick', 
                requirement: '3 different Plastic colors', 
                check: (types) => countUniqueByPrefix(types, 'Plastic') >= 3,
                progress: (types, tokenIds) => ({ current: countUniqueByPrefix(types, 'Plastic'), needed: 3 })
            },
            { 
                name: 'robot_hatrick', 
                requirement: '3 different Robot colors', 
                check: (types) => countUniqueByPrefix(types, 'Robot') >= 3,
                progress: (types, tokenIds) => ({ current: countUniqueByPrefix(types, 'Robot'), needed: 3 })
            },
            { 
                name: 'gradient_high_five', 
                requirement: '5 different Gradient colors', 
                check: (types) => countUniqueByPrefix(types, 'Gradient') >= 5,
                progress: (types, tokenIds) => ({ current: countUniqueByPrefix(types, 'Gradient'), needed: 5 })
            },
            { 
                name: 'plastic_high_five', 
                requirement: '5 different Plastic colors', 
                check: (types) => countUniqueByPrefix(types, 'Plastic') >= 5,
                progress: (types, tokenIds) => ({ current: countUniqueByPrefix(types, 'Plastic'), needed: 5 })
            },
            { 
                name: 'robot_high_five', 
                requirement: '5 different Robot colors', 
                check: (types) => countUniqueByPrefix(types, 'Robot') >= 5,
                progress: (types, tokenIds) => ({ current: countUniqueByPrefix(types, 'Robot'), needed: 5 })
            },
            { 
                name: 'power_duo', 
                requirement: '2 GVCs of same type & color', 
                check: (types) => hasDuplicateType(types),
                progress: (types, tokenIds) => ({ current: getMaxDuplicateCount(types), needed: 2 })
            },
            { 
                name: 'chris_favorite', 
                requirement: '2 Grayscale GVCs', 
                check: (types) => countByType(types, 'Grayscale') >= 2,
                progress: (types, tokenIds) => ({ current: countByType(types, 'Grayscale'), needed: 2 })
            },
            { 
                name: 'multi_type_master', 
                requirement: '1 Plastic + 1 Gradient + 1 Robot', 
                check: (types) => hasAllThreeTypes(types),
                progress: (types, tokenIds) => {
                    let count = 0;
                    if (types.some(t => t && t.startsWith('Plastic'))) count++;
                    if (types.some(t => t && t.startsWith('Gradient'))) count++;
                    if (types.some(t => t && t.startsWith('Robot'))) count++;
                    return { current: count, needed: 3 };
                }
            },
            { 
                name: 'yin_n_yang', 
                requirement: 'Own Grayscale + Rainbow', 
                check: (types) => hasGrayscaleAndRainbow(types),
                progress: (types, tokenIds) => {
                    let count = 0;
                    if (types.some(t => t === 'Grayscale')) count++;
                    if (types.some(t => t === 'Rainbow')) count++;
                    return { current: count, needed: 2 };
                }
            },
            { 
                name: 'mountain_goat', 
                requirement: '2 NFTs with Snowboard Goggles or Puffy Jacket', 
                check: (types, tokenIds) => hasMountainGoatTraits(tokenIds),
                progress: (types, tokenIds) => ({ current: countMountainGoatTraits(tokenIds), needed: 2 })
            }
        ];
        
        // Helper functions for combo badge checks
        function countUniqueByPrefix(types, prefix) {
            const unique = new Set(types.filter(t => t && t.startsWith(prefix)));
            return unique.size;
        }
        
        function countByType(types, exactType) {
            return types.filter(t => t === exactType).length;
        }
        
        function hasDuplicateType(types) {
            const counts = {};
            for (const t of types) {
                if (t) {
                    counts[t] = (counts[t] || 0) + 1;
                    if (counts[t] >= 2) return true;
                }
            }
            return false;
        }
        
        function getMaxDuplicateCount(types) {
            const counts = {};
            let max = 0;
            for (const t of types) {
                if (t) {
                    counts[t] = (counts[t] || 0) + 1;
                    max = Math.max(max, counts[t]);
                }
            }
            return Math.min(max, 2); // Cap at 2 since that's the goal
        }
        
        function hasAllThreeTypes(types) {
            const hasPlastic = types.some(t => t && t.startsWith('Plastic'));
            const hasGradient = types.some(t => t && t.startsWith('Gradient'));
            const hasRobot = types.some(t => t && t.startsWith('Robot'));
            return hasPlastic && hasGradient && hasRobot;
        }
        
        function hasGrayscaleAndRainbow(types) {
            const hasGrayscale = types.some(t => t === 'Grayscale');
            const hasRainbow = types.some(t => t === 'Rainbow');
            return hasGrayscale && hasRainbow;
        }
        
        function hasMountainGoatTraits(tokenIds) {
            return countMountainGoatTraits(tokenIds) >= 2;
        }
        
        function countMountainGoatTraits(tokenIds) {
            let count = 0;
            for (const tokenId of tokenIds) {
                const traits = specialTraitsData[tokenId] || specialTraitsData[String(tokenId)];
                if (traits && traits.length > 0) {
                    count++;
                }
            }
            return Math.min(count, 2); // Cap at 2 since that's the goal
        }
        
        // Store combo badge progress for display
        let comboBadgeProgress = {};
        
        function calculateComboBadges(tokenIds) {
            // Get types for all owned tokens
            const ownedTypes = tokenIds.map(id => typeData[id] || typeData[String(id)]).filter(t => t);
            console.log('Owned types:', ownedTypes);
            
            // Store globally for use in renderMissingBadges
            ownedTypesGlobal = ownedTypes;
            
            const results = {};
            comboBadgeProgress = {}; // Reset progress
            
            COMBO_BADGES.forEach(badge => {
                const earned = badge.check(ownedTypes, tokenIds);
                results[badge.name] = earned;
                
                // Calculate progress for missing badges
                if (!earned && badge.progress) {
                    comboBadgeProgress[badge.name] = badge.progress(ownedTypes, tokenIds);
                }
            });
            
            return results;
        }
        
        // Total badge count constant (for completion calculation)
        const TOTAL_BADGES = 89;
        
        function processResults(tokenIds, vibestrBalance = 0) {
            // Get badges for these tokens
            walletBadges = {};
            let totalBadgeCount = 0;
            
            // Use tokenToBadges if available (faster)
            if (window.tokenToBadges) {
                tokenIds.forEach(tokenId => {
                    const badges = window.tokenToBadges[tokenId] || window.tokenToBadges[String(tokenId)] || [];
                    badges.forEach(badge => {
                        if (!walletBadges[badge]) {
                            walletBadges[badge] = [];
                        }
                        walletBadges[badge].push(tokenId);
                        totalBadgeCount++;
                    });
                });
            } else {
                // Fallback: check each badge's token list
                tokenIds.forEach(tokenId => {
                    Object.entries(badgeData).forEach(([badge, tokens]) => {
                        let tokenList = Array.isArray(tokens) ? tokens : Object.values(tokens);
                        const hasToken = tokenList.some(t => 
                            String(t) === String(tokenId) || parseInt(t) === parseInt(tokenId)
                        );
                        
                        if (hasToken) {
                            if (!walletBadges[badge]) {
                                walletBadges[badge] = [];
                            }
                            walletBadges[badge].push(tokenId);
                            totalBadgeCount++;
                        }
                    });
                });
            }
            
            // Count NFT-based badges first (before adding meta badges)
            const nftBadgeCount = Object.keys(walletBadges).length;
            
            // Calculate combo badges based on NFT types owned
            const comboBadges = calculateComboBadges(tokenIds);
            const earnedComboBadges = [];
            const missingComboBadges = [];
            
            Object.entries(comboBadges).forEach(([badge, earned]) => {
                if (earned) {
                    walletBadges[badge] = ['meta'];
                    earnedComboBadges.push(badge);
                } else {
                    missingComboBadges.push(badge);
                }
            });
            
            // Add VIBESTR Tier Badges (based on token holdings) - BEFORE collection badges
            const earnedVibestrBadges = [];
            const missingVibestrBadges = [];
            VIBESTR_TIERS.forEach(tier => {
                if (vibestrBalance >= tier.threshold) {
                    walletBadges[tier.name] = ['meta'];
                    earnedVibestrBadges.push(tier.name);
                } else {
                    missingVibestrBadges.push(tier.name);
                }
            });
            
            // Count total badges BEFORE collection badges (NFT + combo + VIBESTR)
            let badgeCountForCollection = Object.keys(walletBadges).length;
            
            // Add Collection Badges (cascading - each badge earned counts toward the next)
            const earnedCollectionBadges = [];
            const missingCollectionBadges = [];
            COLLECTION_BADGE_THRESHOLDS.forEach(threshold => {
                const badgeName = `collection_${threshold}`;
                if (badgeCountForCollection >= threshold) {
                    walletBadges[badgeName] = ['meta'];
                    earnedCollectionBadges.push(badgeName);
                    badgeCountForCollection++; // This badge now counts toward the next threshold!
                } else {
                    missingCollectionBadges.push(badgeName);
                }
            });
            
            // Find missing badges
            const allBadges = Object.keys(badgeData);
            const ownedBadgeNames = Object.keys(walletBadges);
            missingBadgesList = allBadges.filter(b => !ownedBadgeNames.includes(b));
            
            // Add missing meta badges to the list
            missingBadgesList = [...missingBadgesList, ...missingComboBadges, ...missingCollectionBadges, ...missingVibestrBadges];
            
            // Add VIBE Bounty Hunter to missing if not at max (2)
            if (vibeBountyHunterCount < 2) {
                missingBadgesList.push('vibe_bounty_hunter');
            }
            
            // Sort missing by rarity (fewer tokens = rarer), meta badges go last
            missingBadgesList.sort((a, b) => {
                // Special badges go to the end
                if (a === 'vibe_bounty_hunter') return 1;
                if (b === 'vibe_bounty_hunter') return -1;
                // Meta badges go after NFT badges but before special
                const aIsMeta = a.startsWith('collection_') || a.startsWith('vibestr_') || COMBO_BADGES.some(cb => cb.name === a);
                const bIsMeta = b.startsWith('collection_') || b.startsWith('vibestr_') || COMBO_BADGES.some(cb => cb.name === b);
                if (aIsMeta && !bIsMeta) return 1;
                if (!aIsMeta && bIsMeta) return -1;
                if (aIsMeta && bIsMeta) return 0;
                
                const aTokens = badgeData[a];
                const bTokens = badgeData[b];
                const aLen = aTokens ? (Array.isArray(aTokens) ? aTokens.length : Object.keys(aTokens).length) : 999;
                const bLen = bTokens ? (Array.isArray(bTokens) ? bTokens.length : Object.keys(bTokens).length) : 999;
                return aLen - bLen;
            });
            
            // Update stats - use fixed total of 89
            const ownedCount = ownedBadgeNames.length + vibeBountyHunterCount;
            const completion = Math.round((ownedCount / TOTAL_BADGES) * 100);
            
            // Find rarest badge owned (fewest NFTs have it) - skip meta badges
            let rarestBadge = '-';
            let rarestCount = Infinity;
            ownedBadgeNames.forEach(badge => {
                if (badge.startsWith('collection_') || badge.startsWith('vibestr_')) return;
                if (COMBO_BADGES.some(cb => cb.name === badge)) return;
                const tokens = badgeData[badge];
                if (!tokens) return;
                const count = Array.isArray(tokens) ? tokens.length : Object.keys(tokens).length;
                if (count < rarestCount) {
                    rarestCount = count;
                    rarestBadge = formatBadgeName(badge);
                }
            });
            
            document.getElementById('nftCount').textContent = tokenIds.length;
            document.getElementById('ownedBadges').textContent = ownedCount;
            document.getElementById('missingBadges').textContent = TOTAL_BADGES - ownedCount;
            document.getElementById('rarestBadge').textContent = rarestBadge;
            document.getElementById('completionPct').textContent = `${completion}%`;
            document.getElementById('progressFill').style.width = `${completion}%`;
            document.getElementById('ownedTabCount').textContent = ownedCount;
            document.getElementById('missingTabCount').textContent = TOTAL_BADGES - ownedCount;
            
            // Render badge grids
            renderOwnedBadges();
            renderMissingBadges();
            
            // Store for modal use
            walletNFTs = tokenIds;
        }
        
        function renderOwnedBadges() {
            const grid = document.getElementById('ownedGrid');
            
            // Helper to check if badge is meta (combo, collection, or vibestr)
            const isMetaBadge = (name) => {
                return name.startsWith('collection_') || 
                       name.startsWith('vibestr_') || 
                       COMBO_BADGES.some(cb => cb.name === name);
            };
            
            // Sort: NFT badges by count, then meta badges at the end
            const sorted = Object.entries(walletBadges).sort((a, b) => {
                const aIsMeta = isMetaBadge(a[0]);
                const bIsMeta = isMetaBadge(b[0]);
                if (aIsMeta && !bIsMeta) return 1;
                if (!aIsMeta && bIsMeta) return -1;
                return b[1].length - a[1].length;
            });
            
            let html = sorted.map(([badge, tokens]) => {
                const color = getBadgeColor(badge);
                const isGradient = color.includes('gradient');
                const style = isGradient 
                    ? `background: ${color}; -webkit-background-clip: text; -webkit-text-fill-color: transparent;`
                    : `color: ${color};`;
                
                const isCombo = COMBO_BADGES.some(cb => cb.name === badge);
                const isMeta = badge.startsWith('collection_') || badge.startsWith('vibestr_') || isCombo;
                const countDisplay = isMeta ? 'âœ“' : `Ã—${tokens.length}`;
                const clickHandler = isMeta ? '' : `onclick="showBadgeNFTs('${badge}', true)"`;
                const cursorStyle = isMeta ? 'cursor: default;' : '';
                
                return `
                    <div class="badge-item" ${clickHandler} style="${cursorStyle}">
                        <span class="badge-name" style="${style}">${formatBadgeName(badge)}</span>
                        <span class="badge-count" style="${isMeta ? 'color: var(--accent-green);' : ''}">${countDisplay}</span>
                    </div>
                `;
            }).join('');
            
            // Add VIBE Bounty Hunter if claimed (1 or 2)
            if (vibeBountyHunterCount > 0) {
                const color = getBadgeColor('vibe_bounty_hunter');
                html += `
                    <div class="badge-item" style="cursor: default;">
                        <span class="badge-name" style="color: ${color};">${formatBadgeName('vibe_bounty_hunter')}</span>
                        <span class="badge-count" style="color: var(--accent-green);">Ã—${vibeBountyHunterCount}</span>
                        <span class="badge-note">Self-reported badge</span>
                    </div>
                `;
            }
            
            grid.innerHTML = html;
        }
        
        function renderMissingBadges() {
            const grid = document.getElementById('missingGrid');
            
            grid.innerHTML = missingBadgesList.map(badge => {
                const color = getBadgeColor(badge);
                const isGradient = color.includes && color.includes('gradient');
                const style = isGradient 
                    ? `background: ${color}; -webkit-background-clip: text; -webkit-text-fill-color: transparent;`
                    : `color: ${color};`;
                
                const comboInfo = COMBO_BADGES.find(cb => cb.name === badge);
                const isCombo = !!comboInfo;
                const isMeta = badge.startsWith('collection_') || badge.startsWith('vibestr_') || isCombo;
                const isSpecial = badge === 'vibe_bounty_hunter';
                let requirement = '';
                let progressBar = '';
                let extraContent = '';
                
                if (isSpecial) {
                    requirement = 'Bought via Gondi or NFT Strategy (max 2)';
                    extraContent = `
                        <div class="bounty-checkbox-container">
                            <input type="checkbox" id="bountyHunterCheck1" onchange="updateBountyHunterCount()" ${vibeBountyHunterCount >= 1 ? 'checked' : ''}>
                            <label for="bountyHunterCheck1">I have 1</label>
                            <input type="checkbox" id="bountyHunterCheck2" onchange="updateBountyHunterCount()" ${vibeBountyHunterCount >= 2 ? 'checked' : ''} style="margin-left: 16px;">
                            <label for="bountyHunterCheck2">I have 2</label>
                        </div>
                        <span class="badge-note">We can't verify this badge - check how many you have</span>
                    `;
                } else if (badge.startsWith('collection_')) {
                    const num = badge.replace('collection_', '');
                    requirement = `Collect ${num} badges`;
                } else if (badge.startsWith('vibestr_')) {
                    const tier = VIBESTR_TIERS.find(t => t.name === badge);
                    requirement = tier ? `Hold ${tier.threshold.toLocaleString()} $VIBESTR` : '';
                } else if (isCombo) {
                    // Show progress for combo badges
                    const progress = comboBadgeProgress[badge];
                    if (progress && progress.current > 0) {
                        const pct = Math.round((progress.current / progress.needed) * 100);
                        requirement = `${progress.current}/${progress.needed} - ${comboInfo.requirement}`;
                        progressBar = `
                            <div class="combo-progress">
                                <div class="combo-progress-fill" style="width: ${pct}%"></div>
                            </div>
                        `;
                        
                        // Show missing colors for High Five and Hatrick badges
                        if (badge.includes('high_five') || badge.includes('hatrick')) {
                            let typePrefix = '';
                            if (badge.startsWith('gradient')) typePrefix = 'Gradient';
                            else if (badge.startsWith('plastic')) typePrefix = 'Plastic';
                            else if (badge.startsWith('robot')) typePrefix = 'Robot';
                            
                            if (typePrefix && ownedTypesGlobal.length > 0) {
                                const missingColors = getMissingColors(ownedTypesGlobal, typePrefix);
                                
                                if (missingColors.length > 0 && missingColors.length <= 5) {
                                    const colorLinks = missingColors.map(color => 
                                        `<a href="${getOpenSeaLink(color)}" target="_blank" style="color: var(--accent-cyan); text-decoration: none; font-size: 12px;">${color.replace(typePrefix + ' ', '')}</a>`
                                    ).join(', ');
                                    extraContent = `<div class="badge-note" style="color: var(--text-secondary);">Missing: ${colorLinks}</div>`;
                                }
                            }
                        }
                        
                        // Show missing for Chris' Favorite (Grayscale)
                        if (badge === 'chris_favorite' && progress.current === 1) {
                            extraContent = `<div class="badge-note" style="color: var(--text-secondary);">Need 1 more: <a href="${getOpenSeaLink('Grayscale')}" target="_blank" style="color: var(--accent-cyan); text-decoration: none; font-size: 12px;">Grayscale</a></div>`;
                        }
                        
                        // Show missing for Yin N' Yang
                        if (badge === 'yin_n_yang' && ownedTypesGlobal.length > 0) {
                            const hasGrayscale = ownedTypesGlobal.some(t => t === 'Grayscale');
                            const hasRainbow = ownedTypesGlobal.some(t => t === 'Rainbow');
                            let missing = [];
                            if (!hasGrayscale) missing.push(`<a href="${getOpenSeaLink('Grayscale')}" target="_blank" style="color: var(--accent-cyan); text-decoration: none; font-size: 12px;">Grayscale</a>`);
                            if (!hasRainbow) missing.push(`<a href="${getOpenSeaLink('Rainbow')}" target="_blank" style="color: var(--accent-cyan); text-decoration: none; font-size: 12px;">Rainbow</a>`);
                            if (missing.length > 0) {
                                extraContent = `<div class="badge-note" style="color: var(--text-secondary);">Missing: ${missing.join(', ')}</div>`;
                            }
                        }
                    } else {
                        requirement = comboInfo.requirement;
                    }
                } else {
                    const tokens = badgeData[badge];
                    const rarity = tokens ? (Array.isArray(tokens) ? tokens.length : Object.keys(tokens).length) : 0;
                    requirement = `${rarity} NFTs have this`;
                }
                
                const clickHandler = (isMeta || isSpecial) ? '' : `onclick="showBadgeNFTs('${badge}', false)"`;
                const cursorStyle = (isMeta || isSpecial) ? 'cursor: default;' : '';
                
                return `
                    <div class="badge-item missing" ${clickHandler} style="${cursorStyle}">
                        <span class="badge-name" style="${style}">${formatBadgeName(badge)}</span>
                        <span class="badge-count">${requirement}</span>
                        ${progressBar}
                        ${extraContent}
                    </div>
                `;
            }).join('');
        }
        
        function updateBountyHunterCount() {
            const check1 = document.getElementById('bountyHunterCheck1');
            const check2 = document.getElementById('bountyHunterCheck2');
            
            // Count checked boxes
            let count = 0;
            if (check1 && check1.checked) count++;
            if (check2 && check2.checked) count++;
            
            vibeBountyHunterCount = count;
            
            // Update counts
            const ownedCount = Object.keys(walletBadges).length + vibeBountyHunterCount;
            const completion = Math.round((ownedCount / TOTAL_BADGES) * 100);
            
            document.getElementById('ownedBadges').textContent = ownedCount;
            document.getElementById('missingBadges').textContent = TOTAL_BADGES - ownedCount;
            document.getElementById('completionPct').textContent = `${completion}%`;
            document.getElementById('progressFill').style.width = `${completion}%`;
            document.getElementById('ownedTabCount').textContent = ownedCount;
            document.getElementById('missingTabCount').textContent = TOTAL_BADGES - ownedCount;
            
            // Update missing list
            if (vibeBountyHunterCount >= 2) {
                missingBadgesList = missingBadgesList.filter(b => b !== 'vibe_bounty_hunter');
            } else if (!missingBadgesList.includes('vibe_bounty_hunter')) {
                missingBadgesList.push('vibe_bounty_hunter');
            }
            
            // Re-render both grids
            renderOwnedBadges();
            renderMissingBadges();
        }
        
        function showTab(tab) {
            const ownedGrid = document.getElementById('ownedGrid');
            const missingGrid = document.getElementById('missingGrid');
            const tabs = document.querySelectorAll('.tab');
            
            tabs.forEach(t => t.classList.remove('active'));
            
            if (tab === 'owned') {
                ownedGrid.style.display = 'grid';
                missingGrid.style.display = 'none';
                tabs[0].classList.add('active');
            } else {
                ownedGrid.style.display = 'none';
                missingGrid.style.display = 'grid';
                tabs[1].classList.add('active');
            }
        }
        
        function showBadgeNFTs(badge, isOwned) {
            const modal = document.getElementById('modal');
            const title = document.getElementById('modalTitle');
            const nftGrid = document.getElementById('modalNFTs');
            
            const badgeColor = getBadgeColor(badge);
            title.textContent = formatBadgeName(badge);
            
            let tokenIds;
            if (isOwned) {
                tokenIds = walletBadges[badge];
            } else {
                const tokens = badgeData[badge];
                const allTokens = Array.isArray(tokens) ? tokens : Object.values(tokens);
                tokenIds = allTokens.slice(0, 50); // Limit to 50 for performance
            }
            
            const CONTRACT = '0xb8ea78fcacef50d41375e44e6814ebba36bb33c4';
            
            nftGrid.innerHTML = tokenIds.map(tokenId => {
                const imgUrl = imageData[tokenId] || imageData[String(tokenId)];
                
                if (imgUrl) {
                    return `
                        <a href="https://opensea.io/assets/ethereum/${CONTRACT}/${tokenId}" target="_blank" class="nft-card">
                            <img src="${imgUrl}" alt="#${tokenId}" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display:none; padding: 20px; text-align: center;">
                                <div style="font-size: 16px; font-weight: 600;">#${tokenId}</div>
                            </div>
                            <div class="nft-id">#${tokenId}</div>
                        </a>
                    `;
                } else {
                    return `
                        <a href="https://opensea.io/assets/ethereum/${CONTRACT}/${tokenId}" target="_blank" class="nft-card" style="text-decoration: none;">
                            <div style="font-family: 'JetBrains Mono', monospace; font-size: 16px; font-weight: 600; color: var(--text-primary); padding: 20px;">#${tokenId}</div>
                            <div style="font-size: 11px; color: var(--accent-cyan);">View on OpenSea â†’</div>
                        </a>
                    `;
                }
            }).join('');
            
            modal.classList.add('active');
        }
        
        function closeModal(event) {
            if (!event || event.target === document.getElementById('modal')) {
                document.getElementById('modal').classList.remove('active');
            }
        }
        
        // Allow Enter key to search
        document.getElementById('walletInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                lookupWallet();
            }
        });
        
        // Close modal on Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
    </script>
</body>
</html>
